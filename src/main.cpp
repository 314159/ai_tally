#include "config.h"
#include "platform_interface.h"
#include "tally_monitor.h"
#include "version.h" // Generated by CMake
#include "websocket_server.h"
#include <boost/asio.hpp>
#include <boost/program_options.hpp>
#include <future> // Required for promise and future
#include <gsl/gsl>
#include <iostream>
#include <memory>
#include <string>
#include <thread>
#include <vector>

namespace po = boost::program_options;

int main(int argc, char** argv)
{
    // Display application and SDK version info at startup
    std::cout << "ATEM Tally WebSocket Server version " << atem::version::GIT_VERSION << "\n"
              << "Using Blackmagic ATEM SDK Version: " << ATEM_SDK_VERSION << "\n";

    // Ensure platform cleanup is always called on exit
    auto _ = gsl::finally([] { platform::cleanup(); });

    try {
        // Initialize platform-specific code
        if (!platform::initialize()) {
            std::cerr << "Failed to initialize platform\n";
            return 1;
        }

        // --- Configuration ---
        auto config = atem::Config();
        auto config_file = std::string("config/server_config.json");

        auto desc = po::options_description("Allowed options");
        desc.add_options()("help,h", "produce help message")(
            "config,c",
            po::value<std::string>(&config_file)->default_value(config_file),
            "Path to configuration file")(
            "listen-address", po::value<std::string>(&config.ws_address),
            "WebSocket server listen address")(
            "listen-port", po::value<unsigned short>(&config.ws_port),
            "WebSocket server listen port")(
            "atem-ip", po::value<std::string>(&config.atem_ip),
            "ATEM switcher IP address")(
            "mock", po::bool_switch(&config.mock_enabled)->default_value(config.mock_enabled), "Enable mock mode")(
            "mock-inputs", po::value<uint16_t>(&config.mock_inputs)->default_value(config.mock_inputs),
            "Number of inputs to show in mock mode");

        auto vm = po::variables_map();
        const auto args = std::vector<std::string>(argv, argv + argc);
        po::store(po::command_line_parser(args).options(desc).run(), vm);
        po::notify(vm);

        if (vm.count("help")) {
            std::cout << "\n"
                      << desc << "\n";
            return 0;
        }

        // Load from the specified config file, then re-apply command-line args to ensure they override.
        config.load_from_file(config_file.c_str());
        po::notify(vm); // This applies the command-line values over the file values.

        // --- Service Setup ---
        auto io_context = boost::asio::io_context();
        const auto address = boost::asio::ip::make_address(config.ws_address);
        const auto port = config.ws_port;

        // Create tally monitor
        auto monitor = std::make_unique<atem::TallyMonitor>(io_context, config);

        // Create server
        auto server = std::make_unique<atem::HttpAndWebSocketServer>(io_context, address, port, config, gsl::make_not_null(monitor.get()));

        // Connect tally updates to websocket broadcasts and TUI
        monitor->on_tally_change([server_ptr = server.get()](const atem::TallyUpdate& update) {
            server_ptr->broadcast_tally_update(update);
        });

        // Connect mode changes to websocket broadcasts
        monitor->on_mode_change([server_ptr = server.get()](bool is_mock) {
            server_ptr->broadcast_mode_change(is_mock);
        });

        // Keep the io_context running until it's explicitly stopped.
        auto work_guard = boost::asio::make_work_guard(io_context);

        // Run the io_context in its own thread for server operations
        auto server_thread = std::thread([&io_context]() {
            io_context.run();
            std::cout << "Server thread finished." << std::endl;
        });

        // Setup signal handling for graceful shutdown
        auto signals = boost::asio::signal_set(io_context, SIGINT, SIGTERM);
        signals.async_wait([&server, &monitor, &work_guard, &signals](const boost::system::error_code&, int) {
            std::cout << "\nSignal received, shutting down gracefully...\n";
            server->stop();
            monitor->stop();

            // Cancel the signal handler to remove it from the io_context's work queue.
            signals.cancel();
            work_guard.reset(); // Allow io_context.run() to exit
        });

        monitor->start();
        server->start();

        // The main thread will now block here until the server_thread has finished.
        if (server_thread.joinable()) {
            server_thread.join();
        }

        std::cout << "Application stopped." << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
