<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATEM Tally Monitor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: inline-block;
            margin-right: 20px;
            font-weight: bold;
        }

        .status-connected {
            color: #4CAF50;
        }

        .status-disconnected {
            color: #f44336;
        }

        .status-mock {
            color: #ff9800;
        }

        .status-live {
            color: #03a9f4;
        }

        .controls {
            margin-bottom: 30px;
            text-align: center;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .tally-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .tally-input {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .tally-input.program {
            border-color: #f44336;
            background: rgba(244, 67, 54, 0.2);
            box-shadow: 0 0 20px rgba(244, 67, 54, 0.3);
        }

        .tally-input.preview {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .tally-input h3 {
            margin: 0 0 10px 0;
            font-size: 1.5em;
        }

        .tally-status {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .status-indicator {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        .status-indicator.on {
            background: #4CAF50;
            color: white;
        }

        .status-indicator.off {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
        }

        .log-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-entry {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .log-info {
            background: rgba(33, 150, 243, 0.2);
        }

        .log-tally {
            background: rgba(76, 175, 80, 0.2);
        }

        .log-error {
            background: rgba(244, 67, 54, 0.2);
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .tally-input.program .status-indicator.on {
            animation: pulse 1s infinite;
        }

    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ATEM Tally Monitor</h1>
            <p>Real-time WebSocket monitoring of ATEM switcher tally states</p>
        </div>

        <div class="status-bar">
            <span class="status-item">
                Connection: <span id="connection-status" class="status-disconnected">Disconnected</span>
            </span>
            <span class="status-item">
                Server: <span id="server-address">ws://localhost:8080</span>
            </span>
            <span class="status-item">
                Last Update: <span id="last-update">Never</span>
            </span>
            <span class="status-item">
                Data Source: <span id="source-status">Unknown</span>
            </span>
        </div>

        <div class="controls">
            <button id="connect-btn" onclick="connect()">Connect</button>
            <button id="disconnect-btn" onclick="disconnect()" disabled>Disconnect</button>
            <button onclick="clearLog()">Clear Log</button>
            <input type="text" id="server-url" placeholder="ws://localhost:8080"
                style="padding: 10px; margin-left: 20px; border-radius: 5px; border: none;">
        </div>

        <div class="tally-grid" id="tally-grid">
            <!-- Tally inputs will be populated by JavaScript -->
        </div>

        <div class="log-container">
            <h3>Connection Log</h3>
            <div id="log-output"></div>
        </div>
    </div>

    <script>
        let websocket = null;
        let tallyStates = {};
        let isConnected = false;

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function () {
            initializeTallyGrid();
            updateServerAddress();
        });

        function initializeTallyGrid() {
            const grid = document.getElementById('tally-grid');
            grid.innerHTML = '';

            // Create 8 tally inputs
            for (let i = 1; i <= 8; i++) {
                const tallyDiv = document.createElement('div');
                tallyDiv.className = 'tally-input';
                tallyDiv.id = `tally-${i}`;

                tallyDiv.innerHTML = `
                    <h3>Input ${i}</h3>
                    <div class="tally-status">
                        <div class="status-indicator off" id="program-${i}">PROGRAM</div>
                        <div class="status-indicator off" id="preview-${i}">PREVIEW</div>
                    </div>
                `;

                grid.appendChild(tallyDiv);

                // Initialize state
                tallyStates[i] = { program: false, preview: false };
            }
        }

        function updateServerAddress() {
            const input = document.getElementById('server-url');
            const display = document.getElementById('server-address');

            input.addEventListener('change', function () {
                display.textContent = this.value || 'ws://localhost:8080';
            });
        }

        function connect() {
            if (isConnected) return;

            const serverUrl = document.getElementById('server-url').value || 'ws://localhost:8080';

            try {
                websocket = new WebSocket(serverUrl);

                websocket.onopen = function (event) {
                    isConnected = true;
                    updateConnectionStatus(true);
                    logMessage('Connected to ATEM Tally Server', 'info');

                    document.getElementById('connect-btn').disabled = true;
                    document.getElementById('disconnect-btn').disabled = false;
                };

                websocket.onmessage = function (event) {
                    try {
                        const data = JSON.parse(event.data);
                        handleMessage(data);
                    } catch (error) {
                        logMessage('Error parsing message: ' + error.message, 'error');
                    }
                };

                websocket.onclose = function (event) {
                    isConnected = false;
                    updateConnectionStatus(false);
                    logMessage('Connection closed', 'info');

                    document.getElementById('connect-btn').disabled = false;
                    document.getElementById('disconnect-btn').disabled = true;

                    // Clear all tally states
                    clearAllTallyStates();

                    // Attempt to reconnect after a delay
                    setTimeout(connect, 2000);
                };

                websocket.onerror = function (error) {
                    logMessage('WebSocket error: ' + error.message, 'error');
                };

            } catch (error) {
                logMessage('Failed to connect: ' + error.message, 'error');
            }
        }

        function disconnect() {
            if (websocket && isConnected) {
                websocket.close();
            }
        }

        function handleMessage(data) {
            updateLastUpdate();

            switch (data.type) {
                case 'welcome':
                    logMessage('Server: ' + data.message, 'info');
                    break;

                case 'tally_update':
                    handleTallyUpdate(data);
                    break;

                default:
                    logMessage('Unknown message type: ' + data.type, 'info');
            }
        }

        function handleTallyUpdate(data) {
            const inputId = data.input;
            const program = data.program;
            const preview = data.preview;

            // Update data source status
            updateSourceStatus(data.mock);

            // Update internal state
            tallyStates[inputId] = { program, preview };

            // Update UI
            updateTallyDisplay(inputId, program, preview);

            // Log the change
            const status = [];
            if (program) status.push('PROGRAM');
            if (preview) status.push('PREVIEW');
            if (status.length === 0) status.push('OFF');

            logMessage(`Input ${inputId}: ${status.join(' + ')}`, 'tally');
        }

        function updateTallyDisplay(inputId, program, preview) {
            const tallyElement = document.getElementById(`tally-${inputId}`);
            const programElement = document.getElementById(`program-${inputId}`);
            const previewElement = document.getElementById(`preview-${inputId}`);

            if (!tallyElement || !programElement || !previewElement) return;

            // Update program indicator
            programElement.className = program ? 'status-indicator on' : 'status-indicator off';

            // Update preview indicator  
            previewElement.className = preview ? 'status-indicator on' : 'status-indicator off';

            // Update tally input styling
            tallyElement.className = 'tally-input';
            if (program) {
                tallyElement.classList.add('program'); // Program takes precedence
            } else if (preview) {
                tallyElement.classList.add('preview');
            }
        }

        function clearAllTallyStates() {
            for (let i = 1; i <= 8; i++) {
                updateTallyDisplay(i, false, false);
                tallyStates[i] = { program: false, preview: false };
            }
        }

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            statusElement.textContent = connected ? 'Connected' : 'Disconnected';
            statusElement.className = connected ? 'status-connected' : 'status-disconnected';
        }

        function updateSourceStatus(isMock) {
            const sourceElement = document.getElementById('source-status');
            sourceElement.textContent = isMock ? 'Mock' : 'Live';
            sourceElement.className = isMock ? 'status-mock' : 'status-live';
        }

        function updateLastUpdate() {
            const now = new Date();
            document.getElementById('last-update').textContent = now.toLocaleTimeString();
        }

        function logMessage(message, type = 'info') {
            const logOutput = document.getElementById('log-output');
            const logEntry = document.createElement('div');

            const timestamp = new Date().toLocaleTimeString();
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;

            logOutput.appendChild(logEntry);
            logOutput.scrollTop = logOutput.scrollHeight;

            // Keep only last 100 entries
            while (logOutput.children.length > 100) {
                logOutput.removeChild(logOutput.firstChild);
            }
        }

        function clearLog() {
            document.getElementById('log-output').innerHTML = '';
        }

        // Auto-connect on page load (optional)
        // setTimeout(connect, 1000);
    </script>
</body>

</html>
